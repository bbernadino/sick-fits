{"ast":null,"code":"import { PAGINATION_QUERY } from '../components/Pagination';\nexport default function paginationField() {\n  return {\n    keyArgs: false,\n    // tells Apollo we will do it\n    read: function read() {\n      var existing = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n      var _ref = arguments.length > 1 ? arguments[1] : undefined,\n          args = _ref.args,\n          cache = _ref.cache;\n\n      console.log({\n        existing: existing,\n        args: args,\n        cache: cache\n      }); // const { skip, first } = args;\n    },\n    merge: function merge() {}\n  };\n} // keyArgs: false, // tells Apollo we will do it\n//     read(existing = [], { args, cache }) {\n//       console.log({ existing, args, cache });\n//       const { skip, first } = args;\n//       // Read the number of items on the page from the cache\n//       const data = cache.readQuery({ query: PAGINATION_QUERY });\n//       const count = data?._allProductsMeta?.count;\n//       const page = skip / first + 1;\n//       const pages = Math.ceil(count / first);\n//       // check if we have existing items\n//       const items = existing.slice(skip, skip + first).filter((x) => x);\n//       if (items.length !== first) {\n//         // we dont have items we must go to network to fetch them\n//         return false;\n//       }\n//       // if there are items, just return them from cache dont need to go to network\n//       if (items.length) {\n//         console.log(\n//           `There are ${items.length} in the cache! Gunna send them to Apollo!`\n//         );\n//         return items;\n//       }\n//       return false; // fallback to network\n//       // first thing it does is ask read function for the items.\n//       // We can do two things:\n//       // first, we can do is retunr the items because the are already in the cache\n//       // second, is to return the false from here, (network request)\n//     },\n//     merge(existing, incoming, { args }) {\n//       const { skip, first } = args;\n//       // this runs when the Apollo client comes back from the network with our products\n//       console.log(`Merging items from the network ${incoming.length}`);\n//       const merged = existing ? existing.slice(0) : [];\n//       for (let i = skip; i < skip + incoming.length; ++i) {\n//         merged[i] = incoming[i - skip];\n//       }\n//       console.log(merged);\n//       // finally we return merged items from the cache\n//       return merged;\n//     },","map":{"version":3,"sources":["C:/Users/Bailey/Desktop/sick-fits/frontend/lib/paginationField.js"],"names":["PAGINATION_QUERY","paginationField","keyArgs","read","existing","args","cache","console","log","merge"],"mappings":"AAAA,SAASA,gBAAT,QAAiC,0BAAjC;AAEA,eAAe,SAASC,eAAT,GAA2B;AACxC,SAAO;AACLC,IAAAA,OAAO,EAAE,KADJ;AACW;AAChBC,IAAAA,IAFK,kBAEgC;AAAA,UAAhCC,QAAgC,uEAArB,EAAqB;;AAAA;AAAA,UAAfC,IAAe,QAAfA,IAAe;AAAA,UAATC,KAAS,QAATA,KAAS;;AACnCC,MAAAA,OAAO,CAACC,GAAR,CAAY;AAAEJ,QAAAA,QAAQ,EAARA,QAAF;AAAYC,QAAAA,IAAI,EAAJA,IAAZ;AAAkBC,QAAAA,KAAK,EAALA;AAAlB,OAAZ,EADmC,CAEnC;AACD,KALI;AAMLG,IAAAA,KANK,mBAMG,CAAE;AANL,GAAP;AAQD,C,CAED;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["import { PAGINATION_QUERY } from '../components/Pagination';\r\n\r\nexport default function paginationField() {\r\n  return {\r\n    keyArgs: false, // tells Apollo we will do it\r\n    read(existing = [], { args, cache }) {\r\n      console.log({ existing, args, cache });\r\n      // const { skip, first } = args;\r\n    },\r\n    merge() {},\r\n  };\r\n}\r\n\r\n// keyArgs: false, // tells Apollo we will do it\r\n//     read(existing = [], { args, cache }) {\r\n//       console.log({ existing, args, cache });\r\n//       const { skip, first } = args;\r\n\r\n//       // Read the number of items on the page from the cache\r\n//       const data = cache.readQuery({ query: PAGINATION_QUERY });\r\n//       const count = data?._allProductsMeta?.count;\r\n//       const page = skip / first + 1;\r\n//       const pages = Math.ceil(count / first);\r\n\r\n//       // check if we have existing items\r\n//       const items = existing.slice(skip, skip + first).filter((x) => x);\r\n//       if (items.length !== first) {\r\n//         // we dont have items we must go to network to fetch them\r\n//         return false;\r\n//       }\r\n\r\n//       // if there are items, just return them from cache dont need to go to network\r\n//       if (items.length) {\r\n//         console.log(\r\n//           `There are ${items.length} in the cache! Gunna send them to Apollo!`\r\n//         );\r\n//         return items;\r\n//       }\r\n\r\n//       return false; // fallback to network\r\n\r\n//       // first thing it does is ask read function for the items.\r\n//       // We can do two things:\r\n//       // first, we can do is retunr the items because the are already in the cache\r\n//       // second, is to return the false from here, (network request)\r\n//     },\r\n//     merge(existing, incoming, { args }) {\r\n//       const { skip, first } = args;\r\n//       // this runs when the Apollo client comes back from the network with our products\r\n//       console.log(`Merging items from the network ${incoming.length}`);\r\n//       const merged = existing ? existing.slice(0) : [];\r\n//       for (let i = skip; i < skip + incoming.length; ++i) {\r\n//         merged[i] = incoming[i - skip];\r\n//       }\r\n//       console.log(merged);\r\n//       // finally we return merged items from the cache\r\n//       return merged;\r\n//     },\r\n"]},"metadata":{},"sourceType":"module"}